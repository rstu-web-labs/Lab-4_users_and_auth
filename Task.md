## Задание
______________________________________________________________________________

## Легенда
**Укоротитель Урлов** становиться всё популярнее, но пользователям всё мало, 
они хотят создавать свои личные наборы ссылок, удалять свои ссылки, а также получать на почту **_Excel_** файлы с отчётами. 

**И мы ответим на это вызов.**

### Разберём наше задание по этапам:  
_Декомпозиция наше всё_
______________________________________________________________________________

#### 1 Создайте новый эндпоинт 

`/api/users/register/` (_POST_) этот эндпоинт должен принимать валидную электронную почту и пароль.

- позаботьтесь об уникальности почты и валидации
- длинна пароля должны быть не менее 8 символов и включать хотя бы одну маленькую английскую букву, хотя бы одну большую и хотя бы одну цифру.

В ответ пользователь должен получить сообщение о необходимости подтвердить свой **_email_** (текст на вас.)

- данные о пользователе необходимо сохранить в БД
- пароль должен храниться в захешированном виде, (SHA256 вам в помощь)


#### 2 Подтверждение электронной почты

Создайте новый эндпоинт:  
`/api/users/email-verification/{verify_token}` (_GET_) этот эндпоинт вы используете для подтверждения электронной почты.

**Как подтверждать?**
После успешной регистрации вам необходимо:  
 - запустить отложенную задачу [Celery](https://docs.celeryq.dev/en/stable/)
 - в этой задаче сгенерировать токен формата `token = <email.baseencode>-SHA256(email.baseencode> + secret)`
 - отправить пользователю ссылку формата http://localhost/api/email-verification/<token>
 - при переходе пользователя по ссылке проверьте сигнатуру, при помощи вашего секретного ключа если она сходиться раскодируйте `<email.baseencode>`и подтвердите почту пользователя, если такой вообще есть.

### 3 Получение токена авторизации
Создайте новый эндпоинт:  
`/api/users/signin/` (_POST_) - этот эндпоинт выдаётся для генерации JWT токена авторизации и refresh токена. (Мы не планируем хранить токены в БД)

- при запросе пользователь передаёт в теле запроса (_**JSON**_) свой email и password 
- после идентификации и аутентификации пользователь получает пару токенов в формате [JWT](https://jwt.io/introduction)

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```
- время жизни `access_token` не должно превышать 1 часа с момента создания
- время жизни `refresh_token` не должно превышать 1 дня с момента создания

### 4 Обновление токена авторизации
Создайте новый эндпоинт:  
`/api/users/refresh/` (_POST_)
- при запросе пользователь передаёт в теле запроса (_**JSON**_) свой **refresh_token** 
```json
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```
- если токен валиден и его срок действия не истёк, сгенерируйте свежую пару `access_token` `refresh_token`  и отдайте пользователю.


## Изменения в основном сервисе

### 5 добавим миграции
И так у нас намечаются изменения в БД, чтобы удобно их накатывать и откатывать нам понадобятся миграции.
[alembic](https://alembic.sqlalchemy.org/en/latest/index.html)

Установите этот пакет и следуйте инструкциям из документации. 

Здесь я мог бы написать как настраивать alembic, но лучше оставлю набор подсказок.
- вам нужен файл `env.py` который сгенерируется после `alembic init`
- в комментариях прописано, что нужно указать, что бы это завелось нужен класс `Base` и его метаинформация, а также url для подключения к БД.
- когда создадите первую миграцию обязательно загляните в БД и в сам файл, убедитесь, что там появились команды с операциями.


### 6 разные пользователи, а вот ссылки одни и теже
Пора задействовать наших пользователей
Теперь создание коротких ссылок возможно в двух режимах
1) Анонимный пользователь (всё работает так же как и работало)
2) Авторизованный пользователь (если пользователь передал валидный токен авторизации то эта короткая ссылка добавиться в его коллекцию)

Что для этого потребуется?
- Добавить в таблицу URLMap **FK** на таблицу user (**nullable**)
- Добавить **UniqueConstrain** на комбинацию полей короткой ссылки и **FK**

Короткая ссылка для авторизованного пользователя, станет длиннее (но не на много)
Если ссылку сгенерировал авторизованный пользователь она будет иметь следующий вид.
`zxcZXC12?г=<user_id>`

В данном случае в базе храниться всё также короткая ссылка `zxcZXC12` но если наш пользователь захочет ей поделиться то надо показать её вот в таком виде.

### 7 Изменения в формате ответа
Теперь ответа от эндпоинта `/api/url/` (**POST**) - создание короткой ссылки будет выглядеть иначе 
- для авторизоавнного пользователя
```json
{
  "url": "https://example.com",
  "custom_url": "zxcZXC12",
  "share_url": "http://my-servise-host/api/url/zxcZXC12?u=12"
}
```
- для анонимного пользователя
```json
{
  "url": "https://example.com",
  "custom_url": "zxcZXC12",
  "share_url": "http://my-servise-host/api/url/zxcZXC12"
}
```
Соответственно при переходе, по персонализированной ссылке мы идём в коллекцию авторизованного пользователя

### 8 Статистика на минималках
Добавьте к моделе, UrlMap счётчик переходов и инкрементируйте его каждый раз при редиректе.

_На самом деле это плохая практика так как у вас автоматически возникнут проблемы с 
эффективным масштабированием, если вам действительно интересно как эффективно собирать статистку и агрегировать логи,
стоит познакомиться с_ 
- [Prometheus](https://prometheus.io/), 
- [Clickhouse](https://clickhouse.com/), 
- [ElasticSearch](https://www.elastic.co/elasticsearch)
Это не все инструменты, но эта троица плотно претендует на звание проф стандарта и всё чаще встречается в новых проектах. 
(Да и собесы)))


### 9 Таблица лидеров
Добавьте эндпоинт:
`/api/url-leaders` (**GET**)
со следующим набором **_query_** параметров
- `order` (опционально) `desc` (default) упорядочить по убыванию значения счётчика переходов `asc` в порядке не убывания.
- `limit` (обязательные) число от 1 до 50 отображает число записей в ответе, наш лимит 50
- `offset` (обязательные) число начиная с которого мы хотим видеть записи
- `type` (опционально) `all`(default), `users`,`anonim`

**Как это работает.**  
 - Параметры **limit** и **offset** - это пресловутая пагинация.
К примеру занчение **limit**=50 говорит, что нужно показать 50 записей, 
а **offset**=50 начиная с 51 (нумерация offset начинается с **0**)
 - `order` наверное вы уже догадались
 - `type` как формировать таблицу лидеров
   - `all` по всем пользователям
   - `users` только по ссылкам авторизованных пользователей
   - `anonim` только по анонимным пользователям
**Формат ответа:**
request - `http://my-servise-host/api/url-leaders?limit=50&offset=50`
```json
{
  "founded": 123,
  "previous": null,
  "next": "http://my-servise-host/api/url-leaders?limit=50&offset=50",
  "items": [
    {
      "url": "https://example.com",
      "custom_url": "zxcZXC12",
      "share_url": "http://my-servise-host/api/url/zxcZXC12",
      "user_id": null,
      "counter": 123456
    },
    {
      "url": "https://example2.com",
      "custom_url": "zxcZXC12",
      "share_url": "http://my-servise-host/api/url/zxcZXC13?u=12",
      "user_id": 12,
      "counter": 123455
    }
  ]
}
```

Поля previous и next формируются относительно первого запроса, т.е. сохраняют все флаги которые были в запросе меняется только **limit** и **offset**

К примеру при запросе типа `http://my-servise-host/api/url-leaders?limit=20&offset=500&type=all&order=desc`
формат ответа:
```json
{
  "founded": 123,
  "previous": "http://my-servise-host/api/url-leaders?limit=20&offset=480&type=all&order=desc",
  "next": "http://my-servise-host/api/url-leaders?limit=20&offset=520&type=all&order=desc",
  "items": []
}
```

Что делать если записи не найдены? Тут решение за вами, многоие сервисы просто игнорируют не валидный **limit** и **offset** пользователей


### 10 Отчёт по ссылкам
Творческое задание, добавьте эндпоинт для получения полной выгрузки объектов одного авторизованного пользователя.
Как назвать эндпоинт? Придумайте сами.
Отчёт должен быть валидным excel файлом (формат за вами) который должен быть оправлен пользователю на почту.
Формирование отчёта и отправка должны быть выполнены через отложенную задачу. 

______________________________________________________________________________
###  Рекомендации
1) Используйте роутер FastAPI для удобной работы с эндпоинтами
2) Используйте линтеры, они уже заботливо установлены и настроены.
3) Добавьте ещё пару контейнеров (или один) с брокером сообщений и хранилищем результатов
4) Добавьте контейнер celery, подключение можно подсмотреть во второй работе.


### Как сдавать на проверку
1) Проверьте, что ваш сервис работает и запускается
2) Проверьте, что сервис валидно отвечает на все запросы и выдаёт нужные коды ответа
3) В README должна появиться подробная документация вашего проекта.
