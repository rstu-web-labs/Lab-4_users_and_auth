## Задание
______________________________________________________________________________

## Легенда
**Укоротитель Урлов** становиться всё популярнее, но пользователям всё мало, 
они хотят создавать свои личные наборы ссылок, удалять свои ссылки, а также получать на почту **_Excel_** файлы с отчётами. 

**И мы ответим на это вызов.**

### Разберём наше задание по этапам:  
_Декомпозиция наше всё_
______________________________________________________________________________

#### 1 Создайте новый эндпоинт 

`/api/users/register/` (_POST_) этот эндпоинт должен принимать валидную электронную почту и пароль.

- позаботьтесь об уникальности почты и валидации
- длинна пароля должны быть не менее 8 символов и включать хотя бы одну маленькую английскую букву, хотя бы одну большую и хотя бы одну цифру.

В ответ пользователь должен получить сообщение о необходимости подтвердить свой **_email_** (текст на вас.)

- данные о пользователе необходимо сохранить в БД
- пароль должен храниться в захешированном виде, (SHA256 вам в помощь)


#### 2 Подтверждение электронной почты

Создайте новый эндпоинт:  
`/api/users/email-verification/{verify_token}` (_GET_) этот эндпоинт вы используете для подтверждения электронной почты.

**Как подтверждать?**
После успешной регистрации вам необходимо:  
 - запустить отложенную задачу [Celery](https://docs.celeryq.dev/en/stable/)
 - в этой задаче сгенерировать токен формата `token = <email.baseencode>-SHA256(email.baseencode> + secret)`
 - отправить пользователю ссылку формата http://localhost/api/email-verification/<token>
 - при переходе пользователя по ссылке проверьте сигнатуру, при помощи вашего секретного ключа если она сходиться раскодируйте `<email.baseencode>`и подтвердите почту пользователя, если такой вообще есть.

### 3 Получение токена авторизации
Создайте новый эндпоинт:  
`/api/users/signin/` (_POST_) - этот эндпоинт выдаётся для генерации JWT токена авторизации и refresh токена. (Мы не планируем хранить токены в БД)

- при запросе пользователь передаёт в теле запроса (_**JSON**_) свой email и password 
- после идентификации и аутентификации пользователь получает пару токенов в формате [JWT](https://jwt.io/introduction)

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```
- время жизни `access_token` не должно превышать 1 часа с момента создания
- время жизни `refresh_token` не должно превышать 1 дня с момента создания

### 4 Обновление токена авторизации
Создайте новый эндпоинт:  
`/api/users/refresh/` (_POST_)
- при запросе пользователь передаёт в теле запроса (_**JSON**_) свой **refresh_token** 
```json
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```
- если токен валиден и его срок действия не истёк, сгенерируйте свежую пару `access_token` `refresh_token`  и отдайте пользователю.


## Изменения в основном сервисе

### 5 добавим миграции
И так у нас намечаются изменения в БД, чтобы удобно их накатывать и откатывать нам понадобятся миграции.
[alembic](https://alembic.sqlalchemy.org/en/latest/index.html)

Установите этот пакет и следуйте инструкциям из документации. 

Здесь я мог бы написать как настраивать alembic, но лучше оставлю набор подсказок.
- вам нужен файл `env.py` который сгенерируется после `alembic init`
- в комментариях прописано, что нужно указать, что бы это завелось нужен класс `Base` и его метаинформация, а также url для подключения к БД.
- когда создадите первую миграцию обязательно загляните в БД и в сам файл, убедитесь, что там появились команды с операциями.


### 6 разные пользователи, а вот ссылки одни и теже

Теперь у модели URLMap появиться внешний ключ на модель пользователя.

# TODO не всё сразу для начала вам хватит над чем подумать

______________________________________________________________________________
###  Рекомендации
1) Используйте роутер FastAPI для удобной работы с эндпоинтами
2) Используйте линтеры, они уже заботливо установлены и настроены.
3) Добавьте ещё пару контейнеров (или один) с брокером сообщений и хранилищем результатов
4) Добавьте контейнер celery, подключение можно подсмотреть во второй работе.


### Как сдавать на проверку
1) Проверьте, что ваш сервис работает и запускается
2) Проверьте, что сервис валидно отвечает на все запросы и выдаёт нужные коды ответа
3) В README должна появиться подробная документация вашего проекта.
